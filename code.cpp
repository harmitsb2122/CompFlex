// global.h

int MEMORY_SIZE = 262144; // 1024 * 256
int OS_SIZE = 1024;       // 1024 * 100
int OS_START = 0;
int OS_END = 1024;                // OS_START + OS_SIZE
int STACK_SIZE = 10240;           // 1024 * 10
int STACK_START = 1024;           // OS_END
int STACK_END = 11264;            // STACK_START + STACK_SIZE
int HEAP_SIZE = 51200;            // 1024 * 50
int HEAP_START = 11264;           // STACK_END
int HEAP_END = 576716800;         // HEAP_START + HEAP_SIZE
int IO_DISPLAY_SIZE = 65536;      // 1024 * 64
int IO_DISPLAY_START = 576716800; // HEAP_END
int IO_DISPLAY_END = 576782336;   // IO_DISPLAY_START + IO_DISPLAY_SIZE
int IO_KEYBOARD_SIZE = 1;

int IO_KEYBOARD_START = 576782336; // IO_DISPLAY_END

// seekto=229376 in memory.txt

int IO_KEYBOARD_END = 576782337; // IO_KEYBOARD_START + IO_KEYBOARD_SIZE
int FONTMAP_SIZE = 2048;         // 1024 * 2
int FONTMAP_START = 576782337;   // IO_KEYBOARD_END
int FONTMAP_END = 576784385;     // FONTMAP_START + FONTMAP_SIZE
int TEMP_SIZE = 38912;           // 1024 * 38
int TEMP_START = 576784385;      // FONTMAP_END
int TEMP_END = 576823297;        // TEMP_START + TEMP_SIZE

// Keyboard constants
int KEYBOARD_WAIT_TIME = 5;

// Control codes

int CTRL_CODE_BACKSPACE = 8; // 0x08
int CTRL_CODE_ENTER = 10;    // 0x0A

int CTRL_CODE_CTRL = 17;     // 0x11
int CTRL_CODE_ALT = 18;      // 0x12
int CTRL_CODE_SHIFT = 16;    // 0x10
int CTRL_CODE_CAPSLOCK = 20; // 0x14
int CTRL_CODE_BACKSPACE = 8; // 0x08

int ROW_CHAR_SIZE = 128;
int COLUMN_CHAR_SIZE = 64;
int SCREEN_LOCK = 0; // 0x00
int MUL_CONS = 9;

int COLUMN = 0;
int LINE = 0;

char *memory;

char **font_map;

// memory.c
int __load_char_as_bits(char c, char *out)
{
  int g, i;
  g = c;
  for (i = 0; i < 8; i++)
  {
    out[i] = g & 1 + '0';
    g = g >> 1;
  }
  return 1;
}

char mread_char(int addr)
{
  return memory[addr];
}

char mwrite(char c, int addr)
{
  memory[addr] = c;
  return memory[addr];
}

// @brief initialize the memory. just create a memory file filled with zeroes
int minit()
{
  int i;
  for (i = 0; i < MEMORY_SIZE; i++)
  {
    memory[i] = 0;
  }
  return 1;
}

// @brief Initializes keyboard
int keyboard_init()
{
  int start, end, i;
  char c;

  start = IO_KEYBOARD_START;
  end = IO_KEYBOARD_START + IO_KEYBOARD_SIZE;

  c = '\0';

  for (i = start; i < end; i++)
  {

    mwrite(c, i);
  }
}

char keyboard_get_input()
{
  char input, f, c;
  int can_break;

  input = 0;
  can_break = 0;

  // printf("Keyboard start: %d\n", IO_KEYBOARD_START);

  for (; true;)
  {
    can_break = false;

    // mclose();
    minit();
    f = mread_char(IO_KEYBOARD_START);
    // printf("Keyboard input: %c\n", f);
    if (f != 0)
    {
      input = f;
      c = 0;
      mwrite(c, IO_KEYBOARD_START);
      can_break = true;

      // removed every logic for meta keys because
      // i highly doubt that it will work due to continuous key press
      // generated by the keyboard

      if (can_break)
      {
        break;
      }
    }
  }
  // mclose();
  return input;
}

int convert_keyinput_to_string(char input, char *out)
{
  if (input == CTRL_CODE_ALT)
  {
    // ENTR
    out[0] = 'E';
    out[1] = 'N';
    out[2] = 'T';
    out[3] = 'R';
  }
  elif (input == CTRL_CODE_ALT)
  {
    // ALT
    out[0] = 'A';
    out[1] = 'L';
    out[2] = 'T';
    out[3] = '\0';
  }
  elif (input == CTRL_CODE_SHIFT)
  {
    // SHFT
    out[0] = 'S';
    out[1] = 'H';
    out[2] = 'F';
    out[3] = 'T';
  }
  else
  {
    out[0] = input;
    out[1] = '\0';
  }
  return 1;
}

char manipulate_input(char c)
{
  return c;
}

int isEscape(char input)
{
  return input == 27; // 0x1B
}

// **************************** UTILITY **************************
// @brief write_char writes a character included in fontmap at the last location
// @note takes care of word wrapping
// @returns 1 if not able to write else 0
int write_char(char c)
{
  // use write and read from mem.c
  if (SCREEN_LOCK == 0)
  {

    if (c == 10) // '\n'
    {
      COLUMN = 0;
      LINE = LINE + 8;
      if (LINE == 8 * COLUMN_CHAR_SIZE)
      {
        LINE = 0;
        COLUMN = 0;

        return 1;
      }

      return 0;
    }
    elif (c == 13) //'\r'
    {
      COLUMN = 0;
      return 0;
    }
    elif (c == 12) //'\f'
    {
      LINE = LINE + 8;
      if (LINE >= 8 * COLUMN_CHAR_SIZE)
      {
        LINE = 0;
        COLUMN = 0;
        return 1;
      }

      return 0;
    }
    elif (c == 9) // '\t'
    {
      COLUMN = COLUMN + 4;
      if (COLUMN >= ROW_CHAR_SIZE)
      {
        COLUMN = 0;
        LINE = LINE + 8;
        if (LINE >= 8 * COLUMN_CHAR_SIZE)
        {
          LINE = 0;
          COLUMN = 0;
          return 1;
        }
      }

      return 0;
    }
    elif (c == CTRL_CODE_BACKSPACE)
    {
      if (COLUMN == 0)
      {
        if (LINE == 0)
        {
          return 0;
        }
        else
        {
          COLUMN = ROW_CHAR_SIZE - 1;
          LINE = LINE - 8;
        }
      }
      else
      {
        COLUMN--;
      }

      int A, i;
      char c;
      A = IO_DISPLAY_START + ROW_CHAR_SIZE * LINE + COLUMN;
      c = 0;
      for (i = 0; i < 8; i++)
      {
        mwrite(c, A + ROW_CHAR_SIZE * i);
      }

      return 0;
    }
    else
    {
      int A, i;
      char font[8];
      for (i = 0; i < 8; i++)
      {
        font[i] = font_map[c][i];
      }

      A = IO_DISPLAY_START + ROW_CHAR_SIZE * LINE + COLUMN; // location of the first character in the line
      for (i = 0; i < 8; i++)
      {
        mwrite(font[i], A + ROW_CHAR_SIZE * i);
      }

      COLUMN++;
      if (COLUMN == ROW_CHAR_SIZE)
      { // if the row is full
        COLUMN = 0;
        LINE = LINE + 8;
        return 0;
      }

      if (LINE == 8 * COLUMN_CHAR_SIZE)
      { // if the screen is full
        LINE = 0;
        COLUMN = 0;

        return 1;
      }

      return 0;
    }
  }
  return 1;
}

int write_char_at(char c, int line, int col)
{
  if (SCREEN_LOCK == 0)
  {

    if (line < 0 || line >= 8 * COLUMN_CHAR_SIZE)
    {
      return 1;
    }
    if (col < 0 || col >= ROW_CHAR_SIZE)
    {
      return 1;
    }

    int A, i;
    char font[8];
    for (i = 0; i < 8; i++)
    {
      font[i] = font_map[c][i];
    }

    A = IO_DISPLAY_START + ROW_CHAR_SIZE * line + col; // location of the first character in the line
    for (i = 0; i < 8; i++)
    {
      mwrite(font[i], A + ROW_CHAR_SIZE * i);
    }

    return 0;
  }

  return 1;
}

// ******************************************************************************

int write_string(char *msg, int len)
{
  int g, i;
  if (SCREEN_LOCK == 0)
  {
    g = 0;
    for (i = 0; i < len; i++)
    {
      g = write_char(msg[i]);

      if (g != 0)
      {
        return g;
      }
    }
    return 0;
  }
}

int write_string_at(char *msg, int len, int line, int col)
{
  int g, i;
  for (i = 0; i < len; i++)
  {
    g = write_char_at(msg[i], line, col);
    if (g != 0)
    {
      return g;
    }

    col++;
    if (col == ROW_CHAR_SIZE)
    {
      col = 0;
      line = line + 8;
    }

    if (line == 8 * COLUMN_CHAR_SIZE)
    {
      line = 0;
      col = 0;

      return 1;
    }
  }
  return 0;
}

int write_int(int a)
{
  if (SCREEN_LOCK == 0)
  {
    char temp[10];
    int count;
    count = 0;
    for (; a > 0;)
    {
      temp[count++] = a % 10 + '0';
      a = a / 10;
    }
    int i;
    for (i = count - 1; i >= 0; i--)
    {
      write_char(temp[i]);
    }

    return 0;
  }

  return 1;
}

int set_cursor_pos(int line, int col)
{
  if (line < 0 || line >= 8 * COLUMN_CHAR_SIZE)
  {
    return 1;
  }
  if (col < 0 || col >= ROW_CHAR_SIZE)
  {
    return 1;
  }

  LINE = line;
  COLUMN = col;

  return 0;
}

int get_cursor_pos(int *vals)
{
  vals[0] = LINE;
  vals[1] = COLUMN;
}

int main()
{
  memory = malloc(sizeof(char) * MEMORY_SIZE);
  return 0;
}